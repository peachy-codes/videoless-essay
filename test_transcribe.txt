 Hello everyone, and welcome to another episode of Coding Adventures. Today I'd like to try and simulate some smoke. We can think of smoke I suppose as loads of little particles suspended in the air, and since air is a fluid it didn't make sense then to model or smoke with a fluid simulation. So this is a particle based fluid simulation I made a while back, which I'm sure could be adapted to our purposes today. Like in another project for example I used it to make some crude pressure waves in the air, in order to try and capture an audio signal. This time though, for the sake of learning new techniques, I want to try a totally different approach that models the fluid not as individual particles, but rather as values on a grid. I have pretty much no idea how this works, but I have found some helpful looking course notes to guide us along. So to begin with, let's briefly ponder the somewhat simplified form of the Navier-Stokes equations describing the flow of an incompressible fluid. In reality, all fluids can be compressed at least a tiny bit, but if pretending otherwise means we don't have to look at equations like this, I'm all for it. So what we have here instead is simply saying that every tiny volume that we're simulating inside the fluid should be accelerated down the pressure gradient, meaning from regions of high pressure towards regions of low pressure to balance things out. Due to inertia though, more dense the fluid is, the harder it will be to accelerate, and so there's a division by the density here to reflect that. The fluid will then also be accelerated by any external forces that might exist, such as gravity or wind or whatever else, and finally there's this viscosity term which causes the velocities of nearby regions to become more similar to one another over time, due to an internal friction force of sorts. Let's say that the multiplier on this is 0 for today though, and for the moment also assume that there aren't any external forces, just to make our lives a bit easier here. Okay, then we also have this tiny equation number 2, just telling us that the divergence of the fluid's velocity should be zero. To think about that, let's picture a single fluid cell in the larger grid we're going to create, and imagine for instance that there's some fluid flowing out across this edge on the right. In that case, the fluid would be diverging away from the cell, which according to the equation we just saw is highly illegal, So to keep things constant, that outflowing fluid would have to be replaced by an equal amount flowing in. And it doesn't matter if that inflow is entirely on the left here, or if there's just a little bit flowing in across all the other edges, as long as it ultimately adds up to zero, things are going swimmingly. So as we can see, knowing the exact velocity of the fluid at each edge, or at least the horizontal component at the left and right edges, and vertical component at the top and bottom is really convenient for checking if the fluid flow is nicely balanced. Let's store it that way in our code then, so I've made a little fluid grid class that takes in the desired number of cells, as well as their physical size in the world, and then initializes these arrays of horizontal and vertical velocities, which kind of awkwardly have slightly different sizes, since if we imagine a 3x2 grid, for instance, that contains a sort of 4x2 grid of left-right edges, and a 3x3 grid of top and bottom edges. Anyway, we can then calculate the divergence value for any cell simply by looking at how fast the velocity is changing across the cell, both horizontally and vertically, and adding those together to get an overall measure that's negative if fluid is mostly flowing out, positive if it's mostly flowing in, and ideally zero if it's perfectly in balance. I also want to start building a little visualization for this, otherwise I find my mental model of what the code is doing can quite quickly diverge from reality, so I've just made a little script that takes in our grid and figures out its total size and so on, so that we can easily look up the position of any cell or any edge. With that, we can simply loop over and draw a little box to represent each cell, and a little arrow to represent each velocity component. Okay, let's try this out with a tiny 5x3 grid perhaps, and just tweak our visualization parameters here. The arrows aren't appearing, because the velocity is all zero at the moment, but I set up a keyboard shortcut to just randomize those, so we can see what it looks like. Now I'd like to visualize the divergence of all of these cells, so I'll just hop back to that code to run our little divergence function on each of them, and blend their colour towards red or blue, depending whether that's negative or positive. Alright, let's Let's take a look, so I'll randomise the velocities again. And now we can see for instance there's a lot of fluid kind of converging and compressing into this cell over here, so it's displayed in bright red. And next we have the opposite problem in bright blue, where the fluid is diverging away. We can try dragging these velocity components around to correct this manually, although it is made a little tricky by the fact that each adjustment affects two cells, not just the one we're trying to fix. I suppose setting all the velocities to zero would be a nice easy way to ensure zero divergence, but of course we can't actually just change these arrows willy-nilly, we're going to have to obey that first equation for how the fluid accelerates. So let's focus on a single cell again, and call that our central cell C, with neighbours on the left, right, top and bottom, and each of these is going to have its own pressure value. Let's also label the edge velocities of our centre cell, so we have velocity left, top and bottom. And the reason we're using u for velocity, by the way, is that we're now going to use v to represent our prediction for the new velocity of the fluid, one tiny time step, into the future. So we could for instance say that the new velocity at the right edge will be equal to its current value, plus the acceleration that the fluid experiences over there, multiplied by a tiny step forwards in time. We know that the acceleration should be equal to the negative pressure gradient of a density, so we can substitute that in. But all that the pressure gradient is, is a measure of how quickly the pressure is increasing across space, and so on our grid, the horizontal component of that that we care about right now would simply be the difference in pressure between the right and centre cells, divided by the distance between them. This by the way is another reason why it's quite convenient to store the velocities in this slightly strange fashion along the edges, it just lines up really nicely with the pressure values on either side for computing the pressure gradient. Anyway, that gives us now this equation. I have colored in green here the values that are constant across the grid, so the time step is the same everywhere of course, as is the size of the cell, and also importantly, the density. We know that the density is unchanging due to that divergence constraint, because if the same amount of fluid must be flowing into every region of space as is flowing out, then the amount of mass in each location must stay the same. Okay, so just to tidy this equation up a tiny bit, I'm going to pop these constants into a letter K to give us this. We can then repeat the exact same process for the left and top and bottom to come up with equations for the new velocities of every edge on our central cell. Unfortunately, this is a bit useless without knowing what the pressure values are. So our goal is actually going to be to solve for the pressure at the central cell, and then hopefully we'll be able to calculate the pressure everywhere. Let's start by combining these four little equations into one big one, and we actually have something that conveniently involves the four edge velocities, it's once again the divergence constraint, since remember our computation for this just looks at how the velocities change across the cell on each axis, and then sees what that adds up to. So we can write that the divergence of our new velocities must be equal to zero, and then plop in our actual calculations for each of those velocities, which gives us a nice big mess, but solving for the central pressure now is just a matter of simple algebra. Alright, so what we've discovered in the end is that the pressure in the center cell is equal to the average pressure of its neighbors minus the size and density of the cell, scaled by the sum of these velocity deltas, over 4 times the time-stab. So we now just need to write some code to actually solve this equation, which is a tiny but tricky since the pressure of each cell involves the unknown pressures of its surrounding cells, and recommended by the notes for this here is an algorithm called the modified incomplete Cholesky conjugate gradient, which it promises is less scary than it sounds, but I'd rather start with something I'm already familiar with, such as Gauss-Seidel iteration for today, since I'm anxious to just finally get some fluid flowing and we can always fiddle with more efficient functions in the future. So in the code I've defined a grid of pressure values, along with constants for the time step and density, and then made a little function that uses the equation we just figured out to update the pressure at any given cell. For the neighboring pressures, we're just using whatever values are currently stored in the grid, so at the outset that would be all zeros. Say for instance then that we calculate the pressure of this cell over here. Right now it happens to have a value of 12.5, but if we then go and compute the pressure of the cell next door to it, that value will now be outdated since it isn't using the latest information about its neighbor. To fix that, we can use the incredible trick of just calculating it again. But now of course the neighbors aren't dated, so we need to fix that as well. And so on and so forth. Quite quickly though, we can see that the values have settled down into a stable state. So let's make a little function that simply steps through the entire grid, updating each pressure value as it goes, and then we can just run that a bunch of times until it hopefully arrives at a stable solution. All right, the numbers have come to a rest, so that's a good sign. And I'll set the solver to just run automatically every frame, so that we can try dragging the velocities around, and get a sense for how that affects the pressure. This seems reasonable enough, but the real test will now be finally using these pressure values to actually update the velocity. So I've got some code here to do that, and just computing the pressure gradient at each edge, scaled by the constant k that we created, and subtracting that from the velocity. Then going back to our grid, let's switch over to the divergence view to see if this gets driven down to zero like it's supposed to. Ah, that's not quite what I wanted. After some scrutiny though, I finally noticed that I had typed out the constant slightly wrong, this just needs to be switched around. Okay, so I'll try running this again. And that's more like it. With the silver running in the background, we can also try dragging these velocities around and see how the other velocities react to maintain the zero divergence. One thing that is a little strange though is that the fluid can currently flow out of the grid into the great void beyond, or in from there as well. So what I'd like to do is mark some cells such as those around the rim as solid and say that the fluid cannot flow across them. That can be enforced when updating the velocities by just setting any velocity stored at the edge of a solid cell to zero. We're going to need to figure out how this affects the pressure though. So returning for a moment to that equation we wrote for the divergence of our new velocities being zero, let's imagine that the left edge for instance is a solid cell, and so this velocity value is going to be forced to zero. With that little modification, we can solve for the central pressure once again, and here's what we end up with. Pairing it to the original result, we can see a very simple pattern for what happens when we add in a solid cell, the velocity and pressure at that edge have both been removed, and the number we're dividing by is reduced by 1. So in the code done, we can just look at which edges of the cell are solid, and use that information to cancel out any pressure and velocity values at those solid edges. They also divide not by 4, but by the number of non-solid edges now, and if that's 0, there can't be any fluid flowing in or out, so it doesn't have a meaningful pressure value, and so I just made it exit early over here with a value of zero. Okay, let's give it a shot, so I'll randomise the velocities, and we can see what our pressure values are looking like at the moment, but then let's switch over to our divergence view again, and run the velocity update, and we can see the divergence has been successfully removed like before, but this time the velocities are all zero along the outer edge of the grid. it. We could try changing those values by hand, but it doesn't have any effect and just snaps back to zero. Only changing the velocities within the fluid region actually does anything now. Alright, now these edge velocities have been very convenient for our calculations thus far, but I think it's finally time for us to figure out what the velocity is at any location on the grid. For example, on this little grid, let's say that we want to know the velocity of the fluid at this point over here. We'll have to make an approximation, of course, based on the values that we do know. And the simplest way we could start with is to just see how that point falls into this block of horizontal velocities here and this block of vertical velocities here and just run a bilinear interpolation on each of those. The way this works is that if we know some quantity at each corner of a quad, like say the colors yellow, red, white, and purple is a random example, then to figure out an appropriate color at some point inside, we can see that the point is 70% the way from left to right, so along the top we'll combine 70% red with 30% yellow to get a sort of orange, and along the bottom 70% purple with 30% white to get a slightly lighter purple. Then vertically our point happens to be halfway between the top and bottom, so we'll blend 50% light purple with 50% orange to finally arrive at this particular shade of pink, and if we repeat that process for every point inside the box, we can see the nice smooth gradient that we get. So I've written up some code to do that, just first figuring out which cell the given point falls into so we can get the values at each corner, and then interpolating those like we talked about. With that, we should now be able to get a nice smooth velocity value from our grid at any point in the world. So let's give it a go. I'm going to cover our grid in these little blue dots, which are just points at which we'll visualise the interpolated velocity, and then let's try tweaking the underlying velocity components. Ah, alright, I got some stuff a bit back to front on my first attempt, but I'm back after fixing a few bugs, and now it's behaving much better. This is with the pressure silver turned off at the moment of course, so let's try it again with that turned on, and we can see how it immediately starts to form these little swirly patterns in order to keep the velocities from diverging. So even though nothing's even flowing yet, I think this already gives a feeling of a Alright, I've quickly made this little velocity brush now, which affects all the values in radius around the mouse, just so we don't have to fiddle with each of them individually. And we can see how that looks here with the interpolated velocities. They're an uplooking super smooth, I suppose due to the low grid resolution and our very crude interpolation scheme, but hopefully they'll be fine for now. Once again I have the silver turned off just to test this in isolation, so if we draw a straight line for example, we just get this simple sausage, whereas with the silver back on, we can see how the velocity is forced to kind of curl back around on itself here. Okay, I'd really like to get this finally flowing now, since at the moment nothing happens unless we're actively interacting with it. By contrast, if we think about the old particle simulation, over there the velocities belonged to these little particles, and caused them to move around, and in that way, the velocities themselves were moving through space. The way we have it set up now though, velocities are associated with cells in our grid, which are hardly about to get up and go anywhere. Like this velocity here, for instance, should actually be moving across the grid. Though not in discrete jumps like this, but rather smoothly over time. So let's imagine a single row in our grid, and we could visualize the values stored at each of of the edges in a little graph like this. Now let's say to start with that we just want these values to move smoothly rightwards over time. To do that, we'll want to know how quickly the values are changing across space, so we can just do a little finite difference approximation to get the slope. Alright, let's test that out working quickly, so I'll just try a few random points, and it's looking good! Now to shift everything a tiny bit to the right, without actually moving the points themselves, the value at each point is going to have to become more like its neighbour to the left. And since the slope tells us how fast the value is changing as we look towards the right, we can simply subtract the slope at each point to achieve that. So that's exactly what I've done in this little test script over here, with that slope also being multiplied by a velocity value, simply set to 1 for rightward's motion, and multiplied also by the time step so that the change happens gradually over time. Alright, I'm excited to see if this works as expected, so let's try it out. And it's pretty much working, although we can see some little artifacts being introduced – I'm guessing due to the discrete nature of our function, and the limited little window of space perhaps that we're working with. Let's quickly see how it looks applied to our actual grid, so the horizontal values should be shifted rightwards, and the vertical values shifted upwards. We can see the same strange little oscillations being introduced here, which is a little concerning, but on the whole it's looking like some sort of angry sea anemone, which I think is pretty cool. But okay, let's return to our test script for a moment, because instead of shifting every value along at a constant velocity, the values in our grid, of course, are the velocities, and so let's try using them as such over here. Then running our little test again, we can see how the positive values are being shifted rightwards while the negative values are now shifted to the left. So that seems to work reasonably well, up until it explodes at least. Anyway, let's try it out on the fluid grid, just in case it magically works better over there. But okay, that was pretty wishful thinking. Maybe if we turned the pressure solver on though, that could kind of counteract things getting so out of control. And it does actually seem to be a lot more stable now, although I do wonder if it will still explode if we just stir things up enough. Alright, well, that wasn't a huge success. The notes do warn of high frequency wiggles and oscillations, which we certainly experience in abundance, and apparently these can be resolved with more sophisticated approximations of that slope value we saw, but while this was fun to play around with quickly, it's actually recommended here that we focus instead on a simpler approach, known as the semi-lagrangian method. So particle-based simulations are referred to as lagrangian in contrast to grid-based simulations like we're doing today, which are labelled Eulerian. What semi-lagrangian means then is that we're going to be imagining some particles in our grid, but not actually creating them. Okay, so let's zoom in on a single velocity component in our grid here, which we want to update for the next frame. If we now picture a particle at this edge, we could easily figure out its velocity there using our interpolation function, and that allows us to calculate where the particle would move to in the next time step. Ideally, we'd then store that velocity at this location in the grid, but we can't just store values at any random position with this approach, and so we'd instead have to somehow distribute it amongst the surrounding edges, which is certainly doable, but sounds like a bit of a headache to be honest. So let's imagine rather taking a step backwards in time to estimate where this particle might have come from, and we'll say then that whatever velocity we find over there is the actual velocity that the particle was travelling with when it landed up on this edge, and obviously for smaller and smaller time steps there will be an increasingly reasonable assumption. Alright, I've implemented this in the code here, so as we saw simply calculating the full velocity at each edge, then backtracking to estimate where a particle at that point might have come from, and then seeing what velocity that particle would actually have had, and using that to update the value at the current edge. That's for the horizontal values, and then I just have basically the same thing again for the vertical values here. I would like to kind of unify things so we don't have all this duplicate code, but we can always worry about such niceties once everything's actually working. So let's see how this goes. I'll start with a solver disabled as usual, and just try to send the fluid flying off to the right. But it's not actually going anywhere right now. I guess the issue is that each point uses its current velocity to look back in time, But the points over here don't actually have any velocity yet. So they need some initial velocity to make this technique work, which feels kind of odd, but fortunately if we have our silver turned on, then we know that that kind of spreads the velocities out a bit as we can see over here, and so if we run our new advection function we can see how these velocities are now gradually moving along like we wanted. Still, this idea feels a little strange to me, so I've been experimenting a bit with the more natural alternative of stepping forwards in time, and then distributing the velocities among the nearby edges. It wasn't a huge success from the outset, but after fixing a bunch of bugs, I was eventually able to get it behaving more reasonably. One issue I am noticing though is how quickly the velocities spread out when the motion isn't perfectly aligned with the grid, and it also seems like a bit of a nightmare to run this in parallel if we want to speed things up or work with much larger grids, since many of those imaginary particles distribute their velocities among the same edges, whereas with the backwards technique, the velocity at each edge is updated independently. So I think I will return to the backwards approach after all, and let's try it out on a bigger grid this time. I'm displaying only the interpolated velocities at the centre of each cell now, just so it's not too cluttered. Alright, let's try stirring this up a bit more vigorously, and we can see from our divergence display that the solver is not really managing to keep up. So let's crank up the number of iterations to something like 30 perhaps, and The performance is struggling somewhat now, just barely making 60 frames a second, but let's see how it goes. And that is looking a lot better. I just realised though that the divergence display is a tiny bit misleading at the moment, because if we look at the little manager script here, each frame is running the pressure silver, then updating the velocities to remove the divergence, and then running our latest advection step, so that the velocities travel across space. Obviously after all of that is the visualization invoked, but the advection obviously introduces divergence that will be resolved on the next frame, so I guess it makes more sense to run the visualization right after the solver phase. Seeing the divergence visually is nice of course, but I actually also want to quickly count up the total divergence present at each step, and just display that value as an error that we can try to minimize. Let's try this out now with just three iterations of the solver as a baseline, and I've actually recorded my mouse inputs here, with everything running at a fixed frame rate, so that we can perfectly replicate this little test with different settings and see how it affects the error that we're getting. For this first test, it's just over 190,000, and let's rerun it now with the iteration simply raised to a more generous value of 15, and see how that goes. Okay, that has brought the error all the way down to around 27,000, and obviously we could keep raising the iterations for a better result, but more iterations is more expensive, so I instead want to try a trick that I vaguely remember reading about, where you multiply the values in the solver by 2, or something like that. I actually don't see how that makes sense, but let's test first and think later. Alright, I totally misremembered the idea, but what I was going for is this method of successive over relaxation, and what we actually want to do is take in some parameter between 1 and 2, and then update the old pressure by adding on the difference between the new and old, multiplied by that parameter. So if the parameter is 1, for instance, then that's the same as simply overwriting the old value with the new, like we were doing before, but if it's greater than 1, then we're overshooting the solver's prediction, essentially saying that we think it's headed in the right direction just a touch too timidly for our intrepid taste. Okay, let's try it out, and that's not looking great. Oh, I just had the parameter set to zero by mistake, so it wasn't updating at all. Alright, let's be aggressive and try a value of 2. But we can already see that that is overshooting too far to other stabilis. Let's give it a go with maybe 1.9 instead, and not the result is not total chaos at least, although we are seeing strange sort of ripples in the divergence from all the overshooting. So far we've just been making things worse, but I'm going to keep trying with a bunch of different values. Alright, and here is a little plot of the results. As we can see, 1.7 gives the lowest error overall for this current setup at least, so let's have a look at that recording. We can still see some obvious artifacts of the overshooting here, which I'm not super thrilled about, but the overall reduction in error is very enticing, so let's go with this is our default value for now. OK, now these little velocity arrows have been very helpful for getting a sense of how things are flowing, but I think it's nice to look at things in different ways, so let's quickly add in a new view mode in which cells are assigned a color based on the speed of the fluid at that location. And then let's give this a little swell and see how it looks. All right, that's pretty cool, and I want to try swooping around in a circle now. And we've made a speedy little donut. One thing we can see quite clearly in this view is how much the velocities kind of diffuse and slow down over time, despite us not having explicitly programmed in that behavior. Viewed optimistically, this is pretty great, because it is actually realistic for the fluid to lose energy over time in the form of heat or whatever, and to exhibit some smoothing out of the velocities from viscosity. But of course, we'd rather have full control over those things parameters in our simulation, instead of them occurring accidentally in arbitrary amounts. Unfortunately, though, it's kind of tricky to avoid in these simulations, since we're always interpolating quantities and making relatively large jumps forward in time to keep the computation times reasonable. But it's something I'd like to learn more about and try to tackle in the future, for sure. But anyway, for today, let's just forge ahead by adding yet another grid into the code, this time finally for our smoke map. So we're going to say that each cell can hold some amount of this smoke matter, and then we'll have this little function here for the advection of the smoke, which is to say it's movement due to the velocity of the fluid that it's suspended in. That can be done in the exact same way that we handled the self-advection of the velocity itself, just looking backwards to find out how much smoke is about to flow into the current cell. Ok, so we can now spawn in some of the smoke, and then let's add a bit of force to the fluid. Alright, that's looking interesting, and let's try swirling this up some more, and maybe add in some extra smoke to play with as well. Much like we've seen the fluid losing energy over time, it looks like some of the smoke is unsurprisingly also being gradually eaten away. I'm not going to try to solve this today either, but just to get a sense for how much we're losing, I've quickly added a little smoke counter to the top left, and we can set up the scene with some initial blobs of smoke over here, and maybe a few extra little ones just for fun, taking us to 5400 units of smoke in total, and let's then swoop in with our velocity brush and see how that plays out. Alright, as you can see, the counter is indeed dropping quite rapidly, all the way down to 4000 at the moment and falling. Still, despite these little conservation problems we're having, I think the fluid is looking pretty good, so I'm excited to try and get this running at a higher resolution. To do that, my plan is to rewrite everything we've done so far as a computator so that we can process loads of cells in parallel on the GPU. The only tricky part I think is the pressure solving, since this Gauss-Seidel method we've been using has access to the new values of each cell as it goes along, which is not possible in parallel. So one alternative is the Jacobi method, in which we're given a temporary map to write the new values to, and we just work exclusively with the old values in our calculations. That means we can update the values in parallel without race conditions introducing any inconsistencies, and once that's done, the maps can be swapped around so that the new values become the old values for the next iteration. Unfortunately, not having continuous access to the most up-to-date values does mean that we typically need to run the Jacobi Solver roughly twice as many times, to reach the same accuracy as Gal Cytl, as we can see from our little benchmark here. And I tried both under and over-relaxing the solver, but with lackluster results. After a bit of research though, I came across the concept of red-black calcital, where we divide our map up into so-called red cells and black cells, just in this simple checkerboard pattern, and the idea is that we can safely update the red cells in parallel, because all their neighbours are black cells, and once that's done, we can obviously update the black cells, because all of their neighbours are red cells. This way we're still doing a lot of work in parallel, but each iteration has fresher intel about the neighbours, so hopefully that uver relaxation scheme will work again. Here's some code to test that out, we just loop over one half of all the cells and figure out the coordinates of each cell on the checkerboard, choosing either the red or black, depending on the oddness of the given pass index, before finally calculating and updating the pressure values as before. Ok, now here's that same plot we had earlier for 15 iterations of Garcidal, with different values for the over relaxation parameter, and I've now filled in the same thing for 30 iterations of the red-black-solver. Each iteration only updates half the map, so it felt fair to compare it twice as many. We can see that it's not as good of course, but for the fact that we can run this in parallel, I'd say it's pretty promising. So I've been working on a little Compute Shader now, which starts out with this preparatory step here to just pre-compute some helpful information for the solver, for instance figuring out which edges the fluid can flow across, based on the map of solid cells, and then packing that into a 4-bit integer, so that we don't have to constantly look up all of the surrounding solid cells during the solve. The velocities also remain constant while we're solving the pressure, so we can fetch those as well and pre-compute that part of the equation. And then here is the solver itself, which just converts the index of the thread it's been given into a checkerboard cell coordinate, like we saw a moment ago, and just unpacks the pre-computer data and uses it along with the neighbouring pressures of course, to compute the new pressure value for the cell. Beyond this pressure solving, everything else was trivial to parallelise, although that didn't stop me from making a bunch of mistakes anyway of course. This one in particular I thought was rather interesting looking. But with the biggest bugs at least finally fixed, I want to set up a little wind tunnel of sorts, in which we just have some constant velocity being applied at the left edge, and constant source of smoke in a little region over there as well. I also want solid edges surrounding the map, except for the right side, which we can leave open for things to flow out into the void. These pressure values out in the void are just set to zero, by the way. But okay, running this now, we can see our smoke streaming out to the right, and let's just come in with our velocity brush and make some little up-down wiggles, perhaps, to see how that reacts. points. This is at a pretty low resolution still by the way, just 160x90 pixels, but it's running at a decent 500 frames per second, with 80 iterations of the solvage frame. Okay, I think that's looking pretty good, so what I want to try doing next is just adding a little obstacle into the scene, which simply sets the underlying cells to solid. Alright, let's try it out. So we can see the smoke splitting into two separate streams that join back together after a bit, and this seems to be stable for a moment, but it then starts to wiggle up and down of its own accord, with the wiggles becoming increasingly vigorous, until it ultimately settles into this steady repeating pattern that we see here, with little swells forming on alternating sides of the circle, and then sort of detaching and spinning off to the side. This is kind of strange behaviour, but I'm very happy to see it, because as you may be aware it's a strange behaviour that happens in the real world as well. It's a phenomenon known as vortex shedding, and is responsible for the beautiful street of swells that can form in the clouds over islands for instance, and we can also see some incredible intricacies in this photograph here of glycerol vapour flowing around a cylinder. Anyway, I quickly want to add a tiny bit of diffusion to the smoke so that it spreads out little over time, and I've done that here using something called the Laplacian, which essentially just looks at how the quantity of smoke in each cell differs from its neighbours, and that's then used to gradually make each cell more similar to its neighbours. The smoke has of course actually been diffusing a bit already just due to the interpolation, but I wanted to be able to speed it up a little. Here we can see that in action, with some coloured smoke just spreading gradually outwards. This is the same way we could implement viscosity by the way, just applying this operation to the velocity field instead. But okay, let's try out this coloured smoke quickly with our little wind tunnel test, just to get a clearer picture perhaps of the alternating nature of the flow. Let's also add in some velocity arrows again, so we can get a sense for how the air is flowing outside of the smoky regions as well, and just for fun I'll also colour the smoke here based on its speed. I'm also curious just to see quickly what the pressure map looks like if we let that play out from the beginning. Alright, now I want to see if we can increase the resolution on this. Maybe we can try going up by a factor of 4 to 640 by 360. So let's run that. we can see it starts out in a strange sort of hiccuping fashion, but it does ultimately still settle down into that vortex shedding state, although it has become very pink, which I think is caused by that smoke diffusion spiraling out of control. So we sadly can't just increase the resolution and expect everything to work, the simulation needs to operate with a smaller time step, and of course also run many more iterations of the pressure solver to reach the same quality. I don't know exactly how these need to scale with the resolution, but let's try quadrupling the simulation framerate as well, and maybe increase the iterations by a factor of 10, and see how that goes. And that seems to be behaving a lot better this time. We will definitely need to explore more advanced techniques for the pressure solving in the future though, to reach the sort of resolutions I'd like, especially if we expanded at some point into three dimensions. of fun now though, I want to try raising the size all the way up to 1920x180, but I'll keep the solver settings the same, because at this resolution it's running at a rather painful 10 frames per second. Even so, the solver is still arriving at this Vortex shedding state, but it's getting a little creative with it, so there's sometimes multiple swells from a single side, and the sizes are kind of all over the place. I do think it looks kind of cool though, so if we're not overly concerned about accuracy, there's no reason we can't have fun messing around at higher resolutions. Like, something I've been wanting to try is initialising the smoke map based on an image. So let's try this out with an old render from the ray tracing series, and we can just come in with our velocity brush and wreak some havoc. You might notice by the way how the smoke, or paint, or whatever we want to call it here, is slowing down very quickly. And there's just a simple setting I added that constantly decays all the velocity vectors towards zero. That way we can at least have some control over the giant mess that we're making. Okay, this is kind of fun to play around with, and I think it'd be interesting to try actually drawing or writing like this, so I've set the brush to now control both the velocity and smoke fields simultaneously, so we can do something like this. That has become eligible rather rapidly though, so we could maybe crank up the velocity dissipation for more controls if slightly less exciting writing experience. This actually led me off on a bit of a tangent experimenting with trying to turn the fluid simulation into a little painting program of sorts. It does need a lot more work still though, so maybe it's something we could explore in a future video. In any case, another idea I had was to load in some image again and this time just try applying random velocities to the fluid each frame, along with the same velocity dissipation factor, and I'm just curious to see how that mixes things up. So here's a random photo I found from a work in progress thumbnail, and let's just increase the strength of the random velocities for a moment, and then bring that back down to zero. It's still looking somewhat recognisable though, so I want to run that again. And now we've ended up with some nice abstract splotches of colour. But I'm getting sidetracked here, what I actually want to focus on for our final little smoke experiment today is to make use of the unused alpha channel of our smoke map to store a temperature value. Once it's in the smoke map, it will be moved along with the fluid just like the smoke, which makes sense, and then I've implemented this super simple buoyancy model proposed in the cost notes, where we compare the current temperature to some ambient reference temperature that will enforce at the boundaries of a map, and then just calculate a force that makes hotter air rise and cooler air sink. We can also have the heavier matter of the smoke kind of drag things down over here as well. These forces are then applied to the velocity map of course, although not at solid edges where the fluid is unable to flow. Alright now I've set up a little circle in the scene over here that radiates heat and also emits smoke, and then I've also added in these two little walls just to channel it slightly. These scene objects by the way are just plopped into this little buffer here that's then looped over each frame to update the smoke map and so on. Display wise for now I'm just going to draw hot regions in red and cold regions in blue, although we don't have any cold objects in the scene yet, and show the concentration of smoke in the remaining green channel. Alright, let's give this a run and see how it goes. Okay, it's a bit more violent than I was expecting, and it seems to be flowing through the walls for some reason. I should probably look into that. Okay, it took a few minutes to hunt down, but I just forgot a rather important exclamation point over here. With that fixed, let's try it again. And now it seems to be behaving much more reasonably. I think this is looking fairly nice already, although it's definitely lacking a bit in the fine detail department, so in the future I want to experiment with sharper interpolation and more accurate integration schemes and look into some tricks like vortex confinement to hopefully still improve a good deal on this initial step we've taken here today. I'm also excited to convert this into three dimensions and just play around with it some more. Perhaps try to simulate a gas giant like Jupiter, or I don't know what exactly yet, but let me know if you have any ideas you'd like to see. For now though, let's quickly see how this looks with just the smoke on its own. And here's a similar setup, just with some extra obstacles, of which this line of tiny balls at the top I've set to freeze and cold, so we can see how the cooler air around them is sinking downwards. I also think it's interesting how the smoke initially forked off to the left and right around the little obstacle in the middle, but then has suddenly switched into our familiar vortex shedding pattern now. I'd be curious to learn more about the sort of mechanism behind this behaviour, so that's something to investigate later. Anyway, I think that's where we're going to end for today. As I said earlier, obviously there's plenty still to experiment with and improve upon in the future, so any suggestions you might have, very welcome as always. Alright, thanks for watching, and an extra thank you to everyone supporting my work over on Patreon. I hope you all enjoyed this smoky journey, and see you again soon for the next one! you